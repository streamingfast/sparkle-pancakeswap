// Code generated by sparkle. DO NOT EDIT.

package prediction

import (
	"bytes"
	"fmt"
	"math/big"

	eth "github.com/streamingfast/eth-go"
	"github.com/streamingfast/sparkle/entity"
	pbcodec "github.com/streamingfast/sparkle/pb/sf/ethereum/codec/v1"
	"github.com/streamingfast/sparkle/subgraph"
)

const (
	FactoryAddress = "0x516ffd7D1e0Ca40b1879935B2De87cb20Fc1124b"
	ZeroAddress    = "0x0000000000000000000000000000000000000000"
)

var (
	FactoryAddressBytes = eth.MustNewAddress(FactoryAddress).Bytes()
	ZeroAddressBytes    = eth.MustNewAddress(ZeroAddress).Bytes()
)

// Aliases for numerical functions
var (
	S           = entity.S
	B           = entity.B
	F           = entity.NewFloat
	FL          = entity.NewFloatFromLiteral
	I           = entity.NewInt
	IL          = entity.NewIntFromLiteral
	bf          = func() *big.Float { return new(big.Float) }
	bi          = func() *big.Int { return new(big.Int) }
	EIGHTEEN_BI = bf().SetInt64(1e18)
)

var Definition = &subgraph.Definition{
	PackageName:         "prediction",
	HighestParallelStep: 0,
	StartBlock:          6950840,
	IncludeFilter:       "",
	Entities: entity.NewRegistry(
		&Market{},
		&Round{},
		&User{},
		&Bet{},
	),
	DDL: ddl,
	Manifest: `specVersion: 0.0.2
description: Pancake Prediction
repository: https://github.com/pancakeswap
schema:
  file: ./prediction.graphql
dataSources:
  - kind: ethereum/contract
    name: Prediction
    network: bsc
    source:
      address: '0x516ffd7D1e0Ca40b1879935B2De87cb20Fc1124b'
      abi: Prediction
      startBlock: 6950840
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.4
      language: wasm/assemblyscript
      file: ../src/prediction/index.ts
      entities:
        - Market
        - Round
        - User
        - Bet
      abis:
        - name: Prediction
          file: ../abis/Prediction.json
      eventHandlers:
        - event: StartRound(indexed uint256,uint256)
          handler: handleStartRound
        - event: LockRound(indexed uint256,uint256,int256)
          handler: handleLockRound
        - event: EndRound(indexed uint256,uint256,int256)
          handler: handleEndRound
        - event: BetBull(indexed address,indexed uint256,uint256)
          handler: handleBetBull
        - event: BetBear(indexed address,indexed uint256,uint256)
          handler: handleBetBear
        - event: Claim(indexed address,indexed uint256,uint256)
          handler: handleClaim
        - event: Pause(uint256)
          handler: handlePause
        - event: Unpause(uint256)
          handler: handleUnpause
`,
	GraphQLSchema: `enum Position {
    Bull
    Bear
    House
}

type Market @entity {
    id: ID!

    epoch: Round
    paused: Boolean!
}

type Round @entity {
    id: ID!

    epoch: BigInt!
    position: Position
    failed: Boolean

    previous: Round

    # Start
    startAt: BigInt!
    startBlock: BigInt!
    startHash: Bytes!

    # Lock
    lockAt: BigInt
    lockBlock: BigInt
    lockHash: Bytes
    lockPrice: BigDecimal

    # End
    endAt: BigInt
    endBlock: BigInt
    endHash: Bytes
    closePrice: BigDecimal # endPrice

    # Bets
    totalBets: BigInt!
    totalAmount: BigDecimal!
    bullBets: BigInt!
    bullAmount: BigDecimal!
    bearBets: BigInt!
    bearAmount: BigDecimal!
    bets: [Bet!]! @derivedFrom(field: "round")
}

type User @entity {
    id: ID!

    # Address
    address: Bytes!

    createdAt: BigInt!
    updatedAt: BigInt!

    # Block
    block: BigInt!

    # Bets
    totalBets: BigInt!
    totalBNB: BigDecimal!
    bets: [Bet!]! @derivedFrom(field: "user")
}

type Bet @entity {
    id: ID!

    # epoch
    round: Round!

    user: User!
    hash: Bytes!

    amount: BigDecimal!
    position: Position!
    claimed: Boolean!
    claimedHash: Bytes

    createdAt: BigInt!
    updatedAt: BigInt!

    # Block
    block: BigInt!
}
`,
	Abis: map[string]string{
		"Prediction": `[
  {
    "inputs": [
      { "internalType": "contract AggregatorV3Interface", "name": "_oracle", "type": "address" },
      { "internalType": "address", "name": "_adminAddress", "type": "address" },
      { "internalType": "address", "name": "_operatorAddress", "type": "address" },
      { "internalType": "uint256", "name": "_intervalBlocks", "type": "uint256" },
      { "internalType": "uint256", "name": "_bufferBlocks", "type": "uint256" },
      { "internalType": "uint256", "name": "_minBetAmount", "type": "uint256" },
      { "internalType": "uint256", "name": "_oracleUpdateAllowance", "type": "uint256" }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": true, "internalType": "uint256", "name": "currentEpoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "BetBear",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": true, "internalType": "uint256", "name": "currentEpoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "BetBull",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": true, "internalType": "uint256", "name": "currentEpoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Claim",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "ClaimTreasury",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "blockNumber", "type": "uint256" },
      { "indexed": false, "internalType": "int256", "name": "price", "type": "int256" }
    ],
    "name": "EndRound",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "blockNumber", "type": "uint256" },
      { "indexed": false, "internalType": "int256", "name": "price", "type": "int256" }
    ],
    "name": "LockRound",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "minBetAmount", "type": "uint256" }
    ],
    "name": "MinBetAmountUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "epoch", "type": "uint256" }],
    "name": "Pause",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "address", "name": "account", "type": "address" }],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "rewardRate", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "treasuryRate", "type": "uint256" }
    ],
    "name": "RatesUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "rewardBaseCalAmount", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "rewardAmount", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "treasuryAmount", "type": "uint256" }
    ],
    "name": "RewardsCalculated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "blockNumber", "type": "uint256" }
    ],
    "name": "StartRound",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "epoch", "type": "uint256" }],
    "name": "Unpause",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "address", "name": "account", "type": "address" }],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "TOTAL_RATE",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "adminAddress",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "betBear", "outputs": [], "stateMutability": "payable", "type": "function" },
  { "inputs": [], "name": "betBull", "outputs": [], "stateMutability": "payable", "type": "function" },
  {
    "inputs": [],
    "name": "bufferBlocks",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "epoch", "type": "uint256" }],
    "name": "claim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "claimTreasury", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "internalType": "address", "name": "user", "type": "address" }
    ],
    "name": "claimable",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "currentEpoch",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "executeRound", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "genesisLockOnce",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "genesisLockRound", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "genesisStartOnce",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "genesisStartRound", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "address", "name": "user", "type": "address" },
      { "internalType": "uint256", "name": "cursor", "type": "uint256" },
      { "internalType": "uint256", "name": "size", "type": "uint256" }
    ],
    "name": "getUserRounds",
    "outputs": [
      { "internalType": "uint256[]", "name": "", "type": "uint256[]" },
      { "internalType": "uint256", "name": "", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "intervalBlocks",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "ledger",
    "outputs": [
      { "internalType": "enum BnbPricePrediction.Position", "name": "position", "type": "uint8" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "bool", "name": "claimed", "type": "bool" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minBetAmount",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "operatorAddress",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "oracleLatestRoundId",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "oracleUpdateAllowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "pause", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "paused",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "internalType": "address", "name": "user", "type": "address" }
    ],
    "name": "refundable",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "rewardRate",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "rounds",
    "outputs": [
      { "internalType": "uint256", "name": "epoch", "type": "uint256" },
      { "internalType": "uint256", "name": "startBlock", "type": "uint256" },
      { "internalType": "uint256", "name": "lockBlock", "type": "uint256" },
      { "internalType": "uint256", "name": "endBlock", "type": "uint256" },
      { "internalType": "int256", "name": "lockPrice", "type": "int256" },
      { "internalType": "int256", "name": "closePrice", "type": "int256" },
      { "internalType": "uint256", "name": "totalAmount", "type": "uint256" },
      { "internalType": "uint256", "name": "bullAmount", "type": "uint256" },
      { "internalType": "uint256", "name": "bearAmount", "type": "uint256" },
      { "internalType": "uint256", "name": "rewardBaseCalAmount", "type": "uint256" },
      { "internalType": "uint256", "name": "rewardAmount", "type": "uint256" },
      { "internalType": "bool", "name": "oracleCalled", "type": "bool" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_adminAddress", "type": "address" }],
    "name": "setAdmin",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_bufferBlocks", "type": "uint256" }],
    "name": "setBufferBlocks",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_intervalBlocks", "type": "uint256" }],
    "name": "setIntervalBlocks",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_minBetAmount", "type": "uint256" }],
    "name": "setMinBetAmount",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_operatorAddress", "type": "address" }],
    "name": "setOperator",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_oracle", "type": "address" }],
    "name": "setOracle",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_oracleUpdateAllowance", "type": "uint256" }],
    "name": "setOracleUpdateAllowance",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_rewardRate", "type": "uint256" }],
    "name": "setRewardRate",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "_treasuryRate", "type": "uint256" }],
    "name": "setTreasuryRate",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasuryAmount",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasuryRate",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "unpause", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "address", "name": "", "type": "address" },
      { "internalType": "uint256", "name": "", "type": "uint256" }
    ],
    "name": "userRounds",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
]
`,
	},
	New: func(base subgraph.Base) subgraph.Subgraph {
		return &Subgraph{
			Base: base,
		}
	},
	MergeFunc: func(step int, current, next entity.Interface) entity.Interface {
		switch next.(type) {
		case interface {
			Merge(step int, next *Market)
		}:
			var curr *Market
			if current == nil {
				return next.(*Market)
			}
			curr = current.(*Market)
			el := next.(*Market)
			el.Merge(step, curr)
			return el
		case interface {
			Merge(step int, next *Round)
		}:
			var curr *Round
			if current == nil {
				return next.(*Round)
			}
			curr = current.(*Round)
			el := next.(*Round)
			el.Merge(step, curr)
			return el
		case interface {
			Merge(step int, next *User)
		}:
			var curr *User
			if current == nil {
				return next.(*User)
			}
			curr = current.(*User)
			el := next.(*User)
			el.Merge(step, curr)
			return el
		case interface {
			Merge(step int, next *Bet)
		}:
			var curr *Bet
			if current == nil {
				return next.(*Bet)
			}
			curr = current.(*Bet)
			el := next.(*Bet)
			el.Merge(step, curr)
			return el
		}
		panic("unsuported merge type")
	},
}

type Subgraph struct {
	subgraph.Base
}

var (
	PositionBull  = entity.Enum("Bull")
	PositionBear  = entity.Enum("Bear")
	PositionHouse = entity.Enum("House")
)

// Market
type Market struct {
	entity.Base
	Epoch  *string     `db:"epoch,nullable" csv:"epoch"`
	Paused entity.Bool `db:"paused" csv:"paused"`
}

func NewMarket(id string) *Market {
	return &Market{
		Base: entity.NewBase(id),
	}
}

// Round
type Round struct {
	entity.Base
	Epoch       entity.Int    `db:"epoch" csv:"epoch"`
	Position    *entity.Enum  `db:"position,nullable" csv:"position"`
	Failed      *entity.Bool  `db:"failed,nullable" csv:"failed"`
	Previous    *string       `db:"previous,nullable" csv:"previous"`
	StartAt     entity.Int    `db:"start_at" csv:"start_at"`
	StartBlock  entity.Int    `db:"start_block" csv:"start_block"`
	StartHash   entity.Bytes  `db:"start_hash" csv:"start_hash"`
	LockAt      *entity.Int   `db:"lock_at,nullable" csv:"lock_at"`
	LockBlock   *entity.Int   `db:"lock_block,nullable" csv:"lock_block"`
	LockHash    entity.Bytes  `db:"lock_hash,nullable" csv:"lock_hash"`
	LockPrice   *entity.Float `db:"lock_price,nullable" csv:"lock_price"`
	EndAt       *entity.Int   `db:"end_at,nullable" csv:"end_at"`
	EndBlock    *entity.Int   `db:"end_block,nullable" csv:"end_block"`
	EndHash     entity.Bytes  `db:"end_hash,nullable" csv:"end_hash"`
	ClosePrice  *entity.Float `db:"close_price,nullable" csv:"close_price"`
	TotalBets   entity.Int    `db:"total_bets" csv:"total_bets"`
	TotalAmount entity.Float  `db:"total_amount" csv:"total_amount"`
	BullBets    entity.Int    `db:"bull_bets" csv:"bull_bets"`
	BullAmount  entity.Float  `db:"bull_amount" csv:"bull_amount"`
	BearBets    entity.Int    `db:"bear_bets" csv:"bear_bets"`
	BearAmount  entity.Float  `db:"bear_amount" csv:"bear_amount"`
}

func NewRound(id string) *Round {
	return &Round{
		Base:        entity.NewBase(id),
		Epoch:       IL(0),
		StartAt:     IL(0),
		StartBlock:  IL(0),
		StartHash:   []byte{},
		LockHash:    []byte{},
		EndHash:     []byte{},
		TotalBets:   IL(0),
		TotalAmount: FL(0),
		BullBets:    IL(0),
		BullAmount:  FL(0),
		BearBets:    IL(0),
		BearAmount:  FL(0),
	}
}

// User
type User struct {
	entity.Base
	Address   entity.Bytes `db:"address" csv:"address"`
	CreatedAt entity.Int   `db:"created_at" csv:"created_at"`
	UpdatedAt entity.Int   `db:"updated_at" csv:"updated_at"`
	Block     entity.Int   `db:"block" csv:"block"`
	TotalBets entity.Int   `db:"total_bets" csv:"total_bets"`
	TotalBNB  entity.Float `db:"total_bnb" csv:"total_bnb"`
}

func NewUser(id string) *User {
	return &User{
		Base:      entity.NewBase(id),
		Address:   []byte{},
		CreatedAt: IL(0),
		UpdatedAt: IL(0),
		Block:     IL(0),
		TotalBets: IL(0),
		TotalBNB:  FL(0),
	}
}

// Bet
type Bet struct {
	entity.Base
	Round       string       `db:"round" csv:"round"`
	User        string       `db:"user" csv:"user"`
	Hash        entity.Bytes `db:"hash" csv:"hash"`
	Amount      entity.Float `db:"amount" csv:"amount"`
	Position    entity.Enum  `db:"position" csv:"position"`
	Claimed     entity.Bool  `db:"claimed" csv:"claimed"`
	ClaimedHash entity.Bytes `db:"claimed_hash,nullable" csv:"claimed_hash"`
	CreatedAt   entity.Int   `db:"created_at" csv:"created_at"`
	UpdatedAt   entity.Int   `db:"updated_at" csv:"updated_at"`
	Block       entity.Int   `db:"block" csv:"block"`
}

func NewBet(id string) *Bet {
	return &Bet{
		Base:        entity.NewBase(id),
		Hash:        []byte{},
		Amount:      FL(0),
		ClaimedHash: []byte{},
		CreatedAt:   IL(0),
		UpdatedAt:   IL(0),
		Block:       IL(0),
	}
}

func (s *Subgraph) HandleBlock(block *pbcodec.Block) error {
	for _, trace := range block.TransactionTraces {
		logs := trace.Receipt.Logs
		for _, log := range logs {
			var ethLog interface{} = log
			eventLog := codecLogToEthLog(ethLog.(*pbcodec.Log))

			if bytes.Equal(FactoryAddressBytes, log.Address) {
				ev, err := DecodePredictionEvent(eventLog)
				if err != nil {
					return fmt.Errorf("parsing event: %w", err)
				}

				switch e := ev.(type) {
				case *PredictionBetBearEvent:
					if err := s.HandlePredictionBetBearEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionBetBear event: %w", err)
					}
				case *PredictionBetBullEvent:
					if err := s.HandlePredictionBetBullEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionBetBull event: %w", err)
					}
				case *PredictionClaimEvent:
					if err := s.HandlePredictionClaimEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionClaim event: %w", err)
					}
				case *PredictionEndRoundEvent:
					if err := s.HandlePredictionEndRoundEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionEndRound event: %w", err)
					}
				case *PredictionLockRoundEvent:
					if err := s.HandlePredictionLockRoundEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionLockRound event: %w", err)
					}
				case *PredictionPauseEvent:
					if err := s.HandlePredictionPauseEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionPause event: %w", err)
					}
				case *PredictionStartRoundEvent:
					if err := s.HandlePredictionStartRoundEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionStartRound event: %w", err)
					}
				case *PredictionUnpauseEvent:
					if err := s.HandlePredictionUnpauseEvent(trace, e); err != nil {
						return fmt.Errorf("handling PredictionUnpause event: %w", err)
					}
				}
			}
		}
	}
	return nil
}

func codecLogToEthLog(l *pbcodec.Log) *eth.Log {
	return &eth.Log{
		Address:    l.Address,
		Topics:     l.Topics,
		Data:       l.Data,
		Index:      l.Index,
		BlockIndex: l.BlockIndex,
	}
}

// Prediction
// PredictionBetBear event

type PredictionBetBearEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender       eth.Address `eth:",indexed"`
	CurrentEpoch *big.Int    `eth:",indexed"`
	Amount       *big.Int    `eth:""`
}

var hashPredictionBetBearEvent = eth.Keccak256([]byte("BetBear(address,uint256,uint256)"))

func IsPredictionBetBearEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionBetBearEvent)
}

func NewPredictionBetBearEvent(log *eth.Log) (*PredictionBetBearEvent, error) {
	var err error
	ev := &PredictionBetBearEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading currentEpoch: %w", err)
	}
	ev.CurrentEpoch = f1.(*big.Int)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// PredictionBetBull event

type PredictionBetBullEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender       eth.Address `eth:",indexed"`
	CurrentEpoch *big.Int    `eth:",indexed"`
	Amount       *big.Int    `eth:""`
}

var hashPredictionBetBullEvent = eth.Keccak256([]byte("BetBull(address,uint256,uint256)"))

func IsPredictionBetBullEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionBetBullEvent)
}

func NewPredictionBetBullEvent(log *eth.Log) (*PredictionBetBullEvent, error) {
	var err error
	ev := &PredictionBetBullEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading currentEpoch: %w", err)
	}
	ev.CurrentEpoch = f1.(*big.Int)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// PredictionClaim event

type PredictionClaimEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender       eth.Address `eth:",indexed"`
	CurrentEpoch *big.Int    `eth:",indexed"`
	Amount       *big.Int    `eth:""`
}

var hashPredictionClaimEvent = eth.Keccak256([]byte("Claim(address,uint256,uint256)"))

func IsPredictionClaimEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionClaimEvent)
}

func NewPredictionClaimEvent(log *eth.Log) (*PredictionClaimEvent, error) {
	var err error
	ev := &PredictionClaimEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading currentEpoch: %w", err)
	}
	ev.CurrentEpoch = f1.(*big.Int)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// PredictionClaimTreasury event

type PredictionClaimTreasuryEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Amount *big.Int `eth:""`
}

var hashPredictionClaimTreasuryEvent = eth.Keccak256([]byte("ClaimTreasury(uint256)"))

func IsPredictionClaimTreasuryEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionClaimTreasuryEvent)
}

func NewPredictionClaimTreasuryEvent(log *eth.Log) (*PredictionClaimTreasuryEvent, error) {
	var err error
	ev := &PredictionClaimTreasuryEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// PredictionEndRound event

type PredictionEndRoundEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch       *big.Int `eth:",indexed"`
	BlockNumber *big.Int `eth:""`
	Price       *big.Int `eth:""`
}

var hashPredictionEndRoundEvent = eth.Keccak256([]byte("EndRound(uint256,uint256,int256)"))

func IsPredictionEndRoundEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionEndRoundEvent)
}

func NewPredictionEndRoundEvent(log *eth.Log) (*PredictionEndRoundEvent, error) {
	var err error
	ev := &PredictionEndRoundEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.BlockNumber, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading blockNumber:  %w", err)
	}
	ev.Price, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading price:  %w", err)
	}
	return ev, nil
}

// PredictionLockRound event

type PredictionLockRoundEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch       *big.Int `eth:",indexed"`
	BlockNumber *big.Int `eth:""`
	Price       *big.Int `eth:""`
}

var hashPredictionLockRoundEvent = eth.Keccak256([]byte("LockRound(uint256,uint256,int256)"))

func IsPredictionLockRoundEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionLockRoundEvent)
}

func NewPredictionLockRoundEvent(log *eth.Log) (*PredictionLockRoundEvent, error) {
	var err error
	ev := &PredictionLockRoundEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.BlockNumber, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading blockNumber:  %w", err)
	}
	ev.Price, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading price:  %w", err)
	}
	return ev, nil
}

// PredictionMinBetAmountUpdated event

type PredictionMinBetAmountUpdatedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch        *big.Int `eth:",indexed"`
	MinBetAmount *big.Int `eth:""`
}

var hashPredictionMinBetAmountUpdatedEvent = eth.Keccak256([]byte("MinBetAmountUpdated(uint256,uint256)"))

func IsPredictionMinBetAmountUpdatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionMinBetAmountUpdatedEvent)
}

func NewPredictionMinBetAmountUpdatedEvent(log *eth.Log) (*PredictionMinBetAmountUpdatedEvent, error) {
	var err error
	ev := &PredictionMinBetAmountUpdatedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.MinBetAmount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading minBetAmount:  %w", err)
	}
	return ev, nil
}

// PredictionOwnershipTransferred event

type PredictionOwnershipTransferredEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	PreviousOwner eth.Address `eth:",indexed"`
	NewOwner      eth.Address `eth:",indexed"`
}

var hashPredictionOwnershipTransferredEvent = eth.Keccak256([]byte("OwnershipTransferred(address,address)"))

func IsPredictionOwnershipTransferredEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionOwnershipTransferredEvent)
}

func NewPredictionOwnershipTransferredEvent(log *eth.Log) (*PredictionOwnershipTransferredEvent, error) {
	var err error
	ev := &PredictionOwnershipTransferredEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading previousOwner: %w", err)
	}
	ev.PreviousOwner = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading newOwner: %w", err)
	}
	ev.NewOwner = f1.(eth.Address)
	return ev, nil
}

// PredictionPause event

type PredictionPauseEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch *big.Int `eth:""`
}

var hashPredictionPauseEvent = eth.Keccak256([]byte("Pause(uint256)"))

func IsPredictionPauseEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionPauseEvent)
}

func NewPredictionPauseEvent(log *eth.Log) (*PredictionPauseEvent, error) {
	var err error
	ev := &PredictionPauseEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Epoch, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading epoch:  %w", err)
	}
	return ev, nil
}

// PredictionPaused event

type PredictionPausedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Account eth.Address `eth:""`
}

var hashPredictionPausedEvent = eth.Keccak256([]byte("Paused(address)"))

func IsPredictionPausedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionPausedEvent)
}

func NewPredictionPausedEvent(log *eth.Log) (*PredictionPausedEvent, error) {
	var err error
	ev := &PredictionPausedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Account, err = dec.DataDecoder.ReadAddress()
	if err != nil {
		return nil, fmt.Errorf("reading account:  %w", err)
	}
	return ev, nil
}

// PredictionRatesUpdated event

type PredictionRatesUpdatedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch        *big.Int `eth:",indexed"`
	RewardRate   *big.Int `eth:""`
	TreasuryRate *big.Int `eth:""`
}

var hashPredictionRatesUpdatedEvent = eth.Keccak256([]byte("RatesUpdated(uint256,uint256,uint256)"))

func IsPredictionRatesUpdatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionRatesUpdatedEvent)
}

func NewPredictionRatesUpdatedEvent(log *eth.Log) (*PredictionRatesUpdatedEvent, error) {
	var err error
	ev := &PredictionRatesUpdatedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.RewardRate, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading rewardRate:  %w", err)
	}
	ev.TreasuryRate, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading treasuryRate:  %w", err)
	}
	return ev, nil
}

// PredictionRewardsCalculated event

type PredictionRewardsCalculatedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch               *big.Int `eth:",indexed"`
	RewardBaseCalAmount *big.Int `eth:""`
	RewardAmount        *big.Int `eth:""`
	TreasuryAmount      *big.Int `eth:""`
}

var hashPredictionRewardsCalculatedEvent = eth.Keccak256([]byte("RewardsCalculated(uint256,uint256,uint256,uint256)"))

func IsPredictionRewardsCalculatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionRewardsCalculatedEvent)
}

func NewPredictionRewardsCalculatedEvent(log *eth.Log) (*PredictionRewardsCalculatedEvent, error) {
	var err error
	ev := &PredictionRewardsCalculatedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.RewardBaseCalAmount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading rewardBaseCalAmount:  %w", err)
	}
	ev.RewardAmount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading rewardAmount:  %w", err)
	}
	ev.TreasuryAmount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading treasuryAmount:  %w", err)
	}
	return ev, nil
}

// PredictionStartRound event

type PredictionStartRoundEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch       *big.Int `eth:",indexed"`
	BlockNumber *big.Int `eth:""`
}

var hashPredictionStartRoundEvent = eth.Keccak256([]byte("StartRound(uint256,uint256)"))

func IsPredictionStartRoundEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionStartRoundEvent)
}

func NewPredictionStartRoundEvent(log *eth.Log) (*PredictionStartRoundEvent, error) {
	var err error
	ev := &PredictionStartRoundEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading epoch: %w", err)
	}
	ev.Epoch = f0.(*big.Int)
	ev.BlockNumber, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading blockNumber:  %w", err)
	}
	return ev, nil
}

// PredictionUnpause event

type PredictionUnpauseEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Epoch *big.Int `eth:""`
}

var hashPredictionUnpauseEvent = eth.Keccak256([]byte("Unpause(uint256)"))

func IsPredictionUnpauseEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionUnpauseEvent)
}

func NewPredictionUnpauseEvent(log *eth.Log) (*PredictionUnpauseEvent, error) {
	var err error
	ev := &PredictionUnpauseEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Epoch, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading epoch:  %w", err)
	}
	return ev, nil
}

// PredictionUnpaused event

type PredictionUnpausedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Account eth.Address `eth:""`
}

var hashPredictionUnpausedEvent = eth.Keccak256([]byte("Unpaused(address)"))

func IsPredictionUnpausedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPredictionUnpausedEvent)
}

func NewPredictionUnpausedEvent(log *eth.Log) (*PredictionUnpausedEvent, error) {
	var err error
	ev := &PredictionUnpausedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.Index),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Account, err = dec.DataDecoder.ReadAddress()
	if err != nil {
		return nil, fmt.Errorf("reading account:  %w", err)
	}
	return ev, nil
}

func DecodePredictionEvent(log *eth.Log) (interface{}, error) {
	if IsPredictionBetBearEvent(log) {
		ev, err := NewPredictionBetBearEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionBetBear event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionBetBullEvent(log) {
		ev, err := NewPredictionBetBullEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionBetBull event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionClaimEvent(log) {
		ev, err := NewPredictionClaimEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionClaim event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionClaimTreasuryEvent(log) {
		ev, err := NewPredictionClaimTreasuryEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionClaimTreasury event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionEndRoundEvent(log) {
		ev, err := NewPredictionEndRoundEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionEndRound event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionLockRoundEvent(log) {
		ev, err := NewPredictionLockRoundEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionLockRound event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionMinBetAmountUpdatedEvent(log) {
		ev, err := NewPredictionMinBetAmountUpdatedEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionMinBetAmountUpdated event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionOwnershipTransferredEvent(log) {
		ev, err := NewPredictionOwnershipTransferredEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionOwnershipTransferred event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionPauseEvent(log) {
		ev, err := NewPredictionPauseEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionPause event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionPausedEvent(log) {
		ev, err := NewPredictionPausedEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionPaused event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionRatesUpdatedEvent(log) {
		ev, err := NewPredictionRatesUpdatedEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionRatesUpdated event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionRewardsCalculatedEvent(log) {
		ev, err := NewPredictionRewardsCalculatedEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionRewardsCalculated event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionStartRoundEvent(log) {
		ev, err := NewPredictionStartRoundEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionStartRound event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionUnpauseEvent(log) {
		ev, err := NewPredictionUnpauseEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionUnpause event: %w", err)
		}
		return ev, nil
	}
	if IsPredictionUnpausedEvent(log) {
		ev, err := NewPredictionUnpausedEvent(log)
		if err != nil {
			return nil, fmt.Errorf("decoding PredictionUnpaused event: %w", err)
		}
		return ev, nil
	}
	return nil, nil
}

func (s *Subgraph) LoadDynamicDataSources(blockNum uint64) error {
	return nil
}

type DDL struct {
	createTables map[string]string
	indexes      map[string][]*index
	schemaSetup  string
}

var ddl *DDL

type index struct {
	createStatement string
	dropStatement   string
}

var createTables = map[string]string{}
var indexes = map[string][]*index{}

func init() {
	ddl = &DDL{
		createTables: map[string]string{},
		indexes:      map[string][]*index{},
	}

	Definition.DDL = ddl

	ddl.createTables["market"] = `
create table if not exists %%SCHEMA%%.market
(
	id text not null,

	"epoch" text,

	"paused" boolean not null,

	vid bigserial not null constraint market_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.market owner to graph;
alter sequence %%SCHEMA%%.market_vid_seq owned by %%SCHEMA%%.market.vid;
alter table only %%SCHEMA%%.market alter column vid SET DEFAULT nextval('%%SCHEMA%%.market_vid_seq'::regclass);
`

	ddl.createTables["round"] = `
create table if not exists %%SCHEMA%%.round
(
	id text not null,

	"epoch" numeric not null,

	"position" %%SCHEMA%%."position",

	"failed" boolean,

	"previous" text,

	"start_at" numeric not null,

	"start_block" numeric not null,

	"start_hash" bytea not null,

	"lock_at" numeric,

	"lock_block" numeric,

	"lock_hash" bytea,

	"lock_price" numeric,

	"end_at" numeric,

	"end_block" numeric,

	"end_hash" bytea,

	"close_price" numeric,

	"total_bets" numeric not null,

	"total_amount" numeric not null,

	"bull_bets" numeric not null,

	"bull_amount" numeric not null,

	"bear_bets" numeric not null,

	"bear_amount" numeric not null,

	vid bigserial not null constraint round_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.round owner to graph;
alter sequence %%SCHEMA%%.round_vid_seq owned by %%SCHEMA%%.round.vid;
alter table only %%SCHEMA%%.round alter column vid SET DEFAULT nextval('%%SCHEMA%%.round_vid_seq'::regclass);
`

	ddl.createTables["user"] = `
create table if not exists %%SCHEMA%%.user
(
	id text not null,

	"address" bytea not null,

	"created_at" numeric not null,

	"updated_at" numeric not null,

	"block" numeric not null,

	"total_bets" numeric not null,

	"total_bnb" numeric not null,

	vid bigserial not null constraint user_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.user owner to graph;
alter sequence %%SCHEMA%%.user_vid_seq owned by %%SCHEMA%%.user.vid;
alter table only %%SCHEMA%%.user alter column vid SET DEFAULT nextval('%%SCHEMA%%.user_vid_seq'::regclass);
`

	ddl.createTables["bet"] = `
create table if not exists %%SCHEMA%%.bet
(
	id text not null,

	"round" text not null,

	"user" text not null,

	"hash" bytea not null,

	"amount" numeric not null,

	"position" %%SCHEMA%%."position",

	"claimed" boolean not null,

	"claimed_hash" bytea,

	"created_at" numeric not null,

	"updated_at" numeric not null,

	"block" numeric not null,

	vid bigserial not null constraint bet_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.bet owner to graph;
alter sequence %%SCHEMA%%.bet_vid_seq owned by %%SCHEMA%%.bet.vid;
alter table only %%SCHEMA%%.bet alter column vid SET DEFAULT nextval('%%SCHEMA%%.bet_vid_seq'::regclass);
`

	ddl.indexes["market"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_block_range_closed on %%SCHEMA%%.market (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_id on %%SCHEMA%%.market (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_updated_block_number on %%SCHEMA%%.market (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_id_block_range_fake_excl on %%SCHEMA%%.market using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_epoch on %%SCHEMA%%.market using gist ("epoch", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_epoch;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists market_paused on %%SCHEMA%%.market using btree ("paused");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.market_paused;`,
		})

		return indexes
	}()

	ddl.indexes["round"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_block_range_closed on %%SCHEMA%%.round (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_id on %%SCHEMA%%.round (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_updated_block_number on %%SCHEMA%%.round (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_id_block_range_fake_excl on %%SCHEMA%%.round using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_epoch on %%SCHEMA%%.round using btree ("epoch");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_epoch;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_position on %%SCHEMA%%.round using btree ("position");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_position;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_failed on %%SCHEMA%%.round using btree ("failed");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_failed;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_previous on %%SCHEMA%%.round using gist ("previous", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_previous;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_start_at on %%SCHEMA%%.round using btree ("start_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_start_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_start_block on %%SCHEMA%%.round using btree ("start_block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_start_block;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_start_hash on %%SCHEMA%%.round using btree ("start_hash");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_start_hash;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_lock_at on %%SCHEMA%%.round using btree ("lock_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_lock_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_lock_block on %%SCHEMA%%.round using btree ("lock_block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_lock_block;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_lock_hash on %%SCHEMA%%.round using btree ("lock_hash");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_lock_hash;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_lock_price on %%SCHEMA%%.round using btree ("lock_price");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_lock_price;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_end_at on %%SCHEMA%%.round using btree ("end_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_end_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_end_block on %%SCHEMA%%.round using btree ("end_block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_end_block;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_end_hash on %%SCHEMA%%.round using btree ("end_hash");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_end_hash;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_close_price on %%SCHEMA%%.round using btree ("close_price");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_close_price;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_total_bets on %%SCHEMA%%.round using btree ("total_bets");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_total_bets;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_total_amount on %%SCHEMA%%.round using btree ("total_amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_total_amount;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_bull_bets on %%SCHEMA%%.round using btree ("bull_bets");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_bull_bets;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_bull_amount on %%SCHEMA%%.round using btree ("bull_amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_bull_amount;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_bear_bets on %%SCHEMA%%.round using btree ("bear_bets");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_bear_bets;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists round_bear_amount on %%SCHEMA%%.round using btree ("bear_amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.round_bear_amount;`,
		})

		return indexes
	}()

	ddl.indexes["user"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_block_range_closed on %%SCHEMA%%.user (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_id on %%SCHEMA%%.user (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_updated_block_number on %%SCHEMA%%.user (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_id_block_range_fake_excl on %%SCHEMA%%.user using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_address on %%SCHEMA%%.user using btree ("address");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_address;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_created_at on %%SCHEMA%%.user using btree ("created_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_created_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_updated_at on %%SCHEMA%%.user using btree ("updated_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_updated_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_block on %%SCHEMA%%.user using btree ("block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_block;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_total_bets on %%SCHEMA%%.user using btree ("total_bets");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_total_bets;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists user_total_bnb on %%SCHEMA%%.user using btree ("total_bnb");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.user_total_bnb;`,
		})

		return indexes
	}()

	ddl.indexes["bet"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_block_range_closed on %%SCHEMA%%.bet (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_id on %%SCHEMA%%.bet (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_updated_block_number on %%SCHEMA%%.bet (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_id_block_range_fake_excl on %%SCHEMA%%.bet using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_round on %%SCHEMA%%.bet using gist ("round", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_round;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_user on %%SCHEMA%%.bet using gist ("user", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_user;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_hash on %%SCHEMA%%.bet using btree ("hash");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_hash;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_amount on %%SCHEMA%%.bet using btree ("amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_amount;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_position on %%SCHEMA%%.bet using btree ("position");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_position;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_claimed on %%SCHEMA%%.bet using btree ("claimed");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_claimed;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_claimed_hash on %%SCHEMA%%.bet using btree ("claimed_hash");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_claimed_hash;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_created_at on %%SCHEMA%%.bet using btree ("created_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_created_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_updated_at on %%SCHEMA%%.bet using btree ("updated_at");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_updated_at;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists bet_block on %%SCHEMA%%.bet using btree ("block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.bet_block;`,
		})

		return indexes
	}()
	ddl.schemaSetup = `
CREATE SCHEMA if not exists %%SCHEMA%%;
DO
$do$
    BEGIN
        IF NOT EXISTS (
                SELECT FROM pg_catalog.pg_roles  -- SELECT list can be empty for this
                WHERE  rolname = 'graph') THEN
            CREATE ROLE graph;
        END IF;
    END
$do$;

set statement_timeout = 0;
set idle_in_transaction_session_timeout = 0;
set client_encoding = 'UTF8';
set standard_conforming_strings = on;
select pg_catalog.set_config('search_path', '', false);
set check_function_bodies = false;
set xmloption = content;
set client_min_messages = warning;
set row_security = off;

create extension if not exists btree_gist with schema %%SCHEMA%%;


create type %%SCHEMA%%.position as enum ('Bull','Bear','House');
alter type %%SCHEMA%%.position owner to graph;


create table if not exists %%SCHEMA%%.cursor
(
	id integer not null
		constraint cursor_pkey
			primary key,
	cursor text
);
alter table %%SCHEMA%%.cursor owner to graph;

create table if not exists %%SCHEMA%%.dynamic_data_source_xxx
(
	id text not null,
	context text not null,
	abi text not null,
	vid bigserial not null
		constraint dynamic_data_source_xxx_pkey
			primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.dynamic_data_source_xxx owner to graph;

create index if not exists dynamic_data_source_xxx_block_range_closed
	on %%SCHEMA%%.dynamic_data_source_xxx (COALESCE(upper(block_range), 2147483647))
	where (COALESCE(upper(block_range), 2147483647) < 2147483647);

create index if not exists dynamic_data_source_xxx_id
	on %%SCHEMA%%.dynamic_data_source_xxx (id);

create index if not exists dynamic_data_source_xxx_abi
	on %%SCHEMA%%.dynamic_data_source_xxx (abi);

`

}

func (d *DDL) InitiateSchema(handleStatement func(statement string) error) error {
	err := handleStatement(d.schemaSetup)
	if err != nil {
		return fmt.Errorf("handle statement: %w", err)
	}
	return nil
}

func (d *DDL) CreateTables(handleStatement func(table string, statement string) error) error {
	for table, statement := range d.createTables {
		err := handleStatement(table, statement)
		if err != nil {
			return fmt.Errorf("handle statement: %w", err)
		}
	}
	return nil
}

func (d *DDL) CreateIndexes(handleStatement func(table string, statement string) error) error {
	for table, idxs := range d.indexes {
		for _, idx := range idxs {
			err := handleStatement(table, idx.createStatement)
			if err != nil {
				return fmt.Errorf("handle statement: %w", err)
			}
		}
	}
	return nil
}

func (d *DDL) DropIndexes(handleStatement func(table string, statement string) error) error {
	for table, idxs := range d.indexes {
		for _, idx := range idxs {
			err := handleStatement(table, idx.dropStatement)
			if err != nil {
				return fmt.Errorf("handle statement: %w", err)
			}
		}
	}
	return nil
}
